import numpy as np

def find_Zc():
    """
    Рассчитывает комплексное сопротивление нагрузки (Zc) на конце линии,
    зная входное сопротивление (Zin) на расстоянии (dz) от этой нагрузки.
    """
    print("----------------------------------------------------------------------------------------------------------\n"
          "Поиск комплексной нагрузки относительно входного сопротивления\n")

    W_input = input("Введите волновое сопротивление линии W (по умолчанию 1): ")
    W = float(W_input) if W_input != '' else 1.0

    Rin_input = input("Введите активную составляющую нагрузки Rin (по умолчанию 0): ")
    Rin = float(Rin_input) if Rin_input != '' else 0.0

    Xin_input = input("Введите реактивную составляющую нагрузки Xin со знаком (по умолчанию 0): ")
    Xin = float(Xin_input) if Xin_input != '' else 0.0

    Zin = complex(Rin, Xin)

    dz = float(input("Введите расстояние от нагрузки, нормированное относительно λ: "))


    # --- Расчет ---

    # Шаг 1: Преобразуем известное входное сопротивление (Zin) во входной коэффициент отражения (Gamma_in)
    # Формула: Gamma = (Z - Z0) / (Z + Z0)
    gamma_in = (Zin - W) / (Zin + W)

    # Шаг 2: Рассчитываем фазовый сдвиг для движения ОТ ГЕНЕРАТОРА К НАГРУЗКЕ.
    # Это обратная операция, поэтому знак в экспоненте меняется на положительный (+).
    # beta * d = 2 * pi * dz
    phase_shift = np.exp(+2j * 2 * np.pi * dz)

    # Шаг 3: Находим коэффициент отражения на нагрузке (Gamma_load), повернув Gamma_in в обратную сторону.
    gamma_load = gamma_in * phase_shift

    # Шаг 4: Преобразуем искомый коэффициент отражения на нагрузке (Gamma_load) обратно в сопротивление нагрузки (Zc)
    # Формула: Z = Z0 * (1 + Gamma) / (1 + Gamma)
    Zc_val = W * (1 + gamma_load) / (1 - gamma_load)

    # --- Вывод результата ---
    print(f"\nСопротивление на конце линии (Zc) составляет:")
    print(f"Zc = {Zc_val.real:.2f}{Zc_val.imag:+.2f}j Ом")

