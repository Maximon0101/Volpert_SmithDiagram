import numpy as np

def find_Zc():
    """
    Рассчитывает комплексное сопротивление нагрузки (Zc) на конце линии,
    зная входное сопротивление (Zin) на расстоянии (dz) от этой нагрузки.
    """
    print("----------------------------------------------------------------------------------------------------------\n"
          "Поиск комплексной нагрузки относительно входного сопротивления\n")

    # --- Ввод данных от пользователя ---
    W_input = input("Введите волновое сопротивление линии W (по умолчанию 100): ")
    # Если пользователь ничего не ввел, используем значение по умолчанию
    if W_input == '':
        W = 100.0
    else:
        W = float(W_input)

    Rin = float(input("Введите активную составляющую входного сопротивления Rin: "))
    Xin = float(input("Введите реактивную составляющую входного сопротивления Xin (со знаком): "))
    Zin = complex(Rin, Xin)

    dz = float(input("Введите расстояние от нагрузки, нормированное относительно λ: "))


    # --- Расчет ---

    # Шаг 1: Преобразуем известное входное сопротивление (Zin) во входной коэффициент отражения (Gamma_in)
    # Формула: Gamma = (Z - Z0) / (Z + Z0)
    gamma_in = (Zin - W) / (Zin + W)

    # Шаг 2: Рассчитываем фазовый сдвиг для движения ОТ ГЕНЕРАТОРА К НАГРУЗКЕ.
    # Это обратная операция, поэтому знак в экспоненте меняется на положительный (+).
    # beta * d = 2 * pi * dz
    phase_shift = np.exp(+2j * 2 * np.pi * dz)

    # Шаг 3: Находим коэффициент отражения на нагрузке (Gamma_load), повернув Gamma_in в обратную сторону.
    gamma_load = gamma_in * phase_shift

    # Шаг 4: Преобразуем искомый коэффициент отражения на нагрузке (Gamma_load) обратно в сопротивление нагрузки (Zc)
    # Формула: Z = Z0 * (1 + Gamma) / (1 + Gamma)
    Zc_val = W * (1 + gamma_load) / (1 - gamma_load)

    # --- Вывод результата ---
    print(f"\nСопротивление на конце линии (Zc) составляет:")
    print(f"Zc = {Zc_val.real:.2f}{Zc_val.imag:+.2f}j Ом")

